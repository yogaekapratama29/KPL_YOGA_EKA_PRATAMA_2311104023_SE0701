import regeneratorRuntime from "regenerator-runtime";
import dedent from "dedent";
// @ts-ignore
import * as getFn from "get-function-location";
import kleur from "kleur";
import path from "path";
import prompts from "prompts";
import { autocomplete } from "./autocomplete";
import { config, setRoot } from "./config";
import { camelCaseToHyphen, formatTable, hyphenToCamelCase } from "./utils";
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
        raw = strings.slice(0);
    }
    return Object.freeze(Object.defineProperties(strings, {
        raw: {
            value: Object.freeze(raw)
        }
    }));
}
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _templateObject() {
    var data = _taggedTemplateLiteral([
        "\n    ",
        "\n\n    ",
        " \n      $ ",
        " <command>\n\n    ",
        "\n      ",
        "\n\n    ",
        "\n      ",
        "\n  "
    ]);
    _templateObject = function _templateObject() {
        return data;
    };
    return data;
}
var getFnLoc = getFn.default;
function padRight(str, length) {
    var padding = Math.max(length - str.length, 0);
    return "".concat(str).concat(" ".repeat(padding));
}
function getValue(param, argQueue, onCancel, cancledRef) {
    return _getValue.apply(this, arguments);
}
function _getValue() {
    _getValue = _asyncToGenerator(regeneratorRuntime.mark(function _callee(param, argQueue, onCancel, cancledRef) {
        var obj, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, prop, selectedType, firstType, ref3, aparentType, literal1, hasArgument, argument, message, ref1, ref2, numVal, boolVal, _iteratorNormalCompletion1, _didIteratorError1, _iteratorError1, _iterator1, _step1, type;
        return regeneratorRuntime.wrap(function _callee$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    if (!cancledRef.current) {
                        _ctx.next = 2;
                        break;
                    }
                    return _ctx.abrupt("return");
                case 2:
                    if (!param.object) {
                        _ctx.next = 31;
                        break;
                    }
                    obj = {};
                    _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    _ctx.prev = 5;
                    _iterator = param.object[Symbol.iterator]();
                case 7:
                    if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                        _ctx.next = 16;
                        break;
                    }
                    prop = _step.value;
                    if (!prop.key) {
                        _ctx.next = 13;
                        break;
                    }
                    _ctx.next = 12;
                    return getValue(prop, argQueue, onCancel, cancledRef);
                case 12:
                    obj[prop.key] = _ctx.sent;
                case 13:
                    _iteratorNormalCompletion = true;
                    _ctx.next = 7;
                    break;
                case 16:
                    _ctx.next = 22;
                    break;
                case 18:
                    _ctx.prev = 18;
                    _ctx.t0 = _ctx["catch"](5);
                    _didIteratorError = true;
                    _iteratorError = _ctx.t0;
                case 22:
                    _ctx.prev = 22;
                    _ctx.prev = 23;
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                case 25:
                    _ctx.prev = 25;
                    if (!_didIteratorError) {
                        _ctx.next = 28;
                        break;
                    }
                    throw _iteratorError;
                case 28:
                    return _ctx.finish(25);
                case 29:
                    return _ctx.finish(22);
                case 30:
                    return _ctx.abrupt("return", obj);
                case 31:
                    selectedType = "";
                    if (!(param.types === undefined)) {
                        _ctx.next = 36;
                        break;
                    }
                    return _ctx.abrupt("return");
                case 36:
                    if (!(param.types.length > 1)) {
                        _ctx.next = 42;
                        break;
                    }
                    _ctx.next = 39;
                    return prompts({
                        type: "autocomplete",
                        name: "type",
                        message: "Select praram type for ".concat(param.name),
                        choices: param.types.map(function(t) {
                            var value = typeof t === "string" ? t : t.name;
                            var title = value;
                            if (title.indexOf(":") !== -1) {
                                var ref = _slicedToArray(title.split(":"), 2), _ = ref[0], literal = ref[1];
                                title = literal;
                            }
                            return {
                                title: title,
                                value: value
                            };
                        })
                    }, {
                        onCancel: onCancel
                    });
                case 39:
                    selectedType = _ctx.sent.type;
                    _ctx.next = 43;
                    break;
                case 42:
                    if (param.types.length === 1) {
                        firstType = param.types[0];
                        selectedType = typeof firstType === "string" ? firstType : firstType.name;
                    }
                case 43:
                    if (!(selectedType.indexOf(":") !== -1)) {
                        _ctx.next = 50;
                        break;
                    }
                    ref3 = _slicedToArray(selectedType.split(":"), 2), aparentType = ref3[0], literal1 = ref3[1];
                    _ctx.t1 = aparentType;
                    _ctx.next = _ctx.t1 === "string" ? 48 : _ctx.t1 === "number" ? 49 : 50;
                    break;
                case 48:
                    return _ctx.abrupt("return", literal1);
                case 49:
                    return _ctx.abrupt("return", +literal1);
                case 50:
                    hasArgument = argQueue.length > 0;
                    argument = argQueue.shift();
                    message = camelCaseToHyphen(param.name);
                    _ctx.t2 = selectedType;
                    _ctx.next = _ctx.t2 === "string" ? 56 : _ctx.t2 === "number" ? 74 : _ctx.t2 === "boolean" ? 93 : _ctx.t2 === "null" ? 102 : _ctx.t2 === "undefined" ? 103 : 104;
                    break;
                case 56:
                    ;
                    if (!(argument !== null && argument !== void 0)) {
                        _ctx.next = 61;
                        break;
                    }
                    _ctx.t4 = argument;
                    _ctx.next = 64;
                    break;
                case 61:
                    _ctx.next = 63;
                    return prompts({
                        type: "text",
                        name: "value",
                        message: message
                    }, {
                        onCancel: onCancel
                    });
                case 63:
                    _ctx.t4 = _ctx.sent.value;
                case 64:
                    _ctx.t5 = ref1 = _ctx.t4;
                    _ctx.t3 = _ctx.t5 !== null;
                    if (!_ctx.t3) {
                        _ctx.next = 68;
                        break;
                    }
                    _ctx.t3 = ref1 !== void 0;
                case 68:
                    if (!_ctx.t3) {
                        _ctx.next = 72;
                        break;
                    }
                    _ctx.t6 = ref1;
                    _ctx.next = 73;
                    break;
                case 72:
                    _ctx.t6 = "";
                case 73:
                    return _ctx.abrupt("return", _ctx.t6);
                case 74:
                    ;
                    if (!(argument !== null && argument !== void 0)) {
                        _ctx.next = 79;
                        break;
                    }
                    _ctx.t8 = argument;
                    _ctx.next = 82;
                    break;
                case 79:
                    _ctx.next = 81;
                    return prompts({
                        type: "number",
                        name: "value",
                        message: message
                    }, {
                        onCancel: onCancel
                    });
                case 81:
                    _ctx.t8 = _ctx.sent.value;
                case 82:
                    _ctx.t9 = ref2 = _ctx.t8;
                    _ctx.t7 = _ctx.t9 !== null;
                    if (!_ctx.t7) {
                        _ctx.next = 86;
                        break;
                    }
                    _ctx.t7 = ref2 !== void 0;
                case 86:
                    if (!_ctx.t7) {
                        _ctx.next = 90;
                        break;
                    }
                    _ctx.t10 = ref2;
                    _ctx.next = 91;
                    break;
                case 90:
                    _ctx.t10 = 0;
                case 91:
                    numVal = _ctx.t10;
                    return _ctx.abrupt("return", +numVal);
                case 93:
                    if (!(argument !== null && argument !== void 0)) {
                        _ctx.next = 97;
                        break;
                    }
                    _ctx.t11 = argument;
                    _ctx.next = 100;
                    break;
                case 97:
                    _ctx.next = 99;
                    return prompts({
                        type: "select",
                        name: "value",
                        message: message,
                        choices: [
                            {
                                value: "true",
                                title: "True"
                            },
                            {
                                value: "false",
                                title: "False"
                            }, 
                        ]
                    }, {
                        onCancel: onCancel
                    });
                case 99:
                    _ctx.t11 = _ctx.sent.value;
                case 100:
                    boolVal = _ctx.t11;
                    return _ctx.abrupt("return", boolVal === "true");
                case 102:
                    return _ctx.abrupt("return", null);
                case 103:
                    return _ctx.abrupt("return", undefined);
                case 104:
                    if (!hasArgument) {
                        _ctx.next = 106;
                        break;
                    }
                    return _ctx.abrupt("return", argument);
                case 106:
                    _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                    _ctx.prev = 107;
                    _iterator1 = param.types[Symbol.iterator]();
                case 109:
                    if (_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done) {
                        _ctx.next = 116;
                        break;
                    }
                    type = _step1.value;
                    if (!(typeof type !== "string" && type.name === selectedType)) {
                        _ctx.next = 113;
                        break;
                    }
                    return _ctx.abrupt("return", getValue(type, argQueue, onCancel, cancledRef));
                case 113:
                    _iteratorNormalCompletion1 = true;
                    _ctx.next = 109;
                    break;
                case 116:
                    _ctx.next = 122;
                    break;
                case 118:
                    _ctx.prev = 118;
                    _ctx.t12 = _ctx["catch"](107);
                    _didIteratorError1 = true;
                    _iteratorError1 = _ctx.t12;
                case 122:
                    _ctx.prev = 122;
                    _ctx.prev = 123;
                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                        _iterator1.return();
                    }
                case 125:
                    _ctx.prev = 125;
                    if (!_didIteratorError1) {
                        _ctx.next = 128;
                        break;
                    }
                    throw _iteratorError1;
                case 128:
                    return _ctx.finish(125);
                case 129:
                    return _ctx.finish(122);
                case 130:
                case "end":
                    return _ctx.stop();
            }
        }, _callee, null, [
            [
                5,
                18,
                22,
                30
            ],
            [
                23,
                ,
                25,
                29
            ],
            [
                107,
                118,
                122,
                130
            ],
            [
                123,
                ,
                125,
                129
            ]
        ]);
    }));
    return _getValue.apply(this, arguments);
}
function help(param) {
    var name = param.name, version = param.version, commands = param.commands;
    return console.log(dedent(_templateObject(), kleur.gray("".concat(name, " ").concat(version)), kleur.bold("Usage:"), name, kleur.bold("Commands:"), formatTable(commands.map(function(c) {
        return [
            c.name,
            c.description
        ];
    }), 6), kleur.bold("Other commands:"), formatTable([
        [
            "help",
            "",
            "Output usage information"
        ],
        [
            "autocomplete",
            "[enable|disable]",
            "Setup autocomplete"
        ], 
    ], 6)) + "\n");
}
var _dir = "";
var _functions = {};
function swallowErrors(fn, onCancel) {
    return _swallowErrors.apply(this, arguments);
}
function _swallowErrors() {
    _swallowErrors = _asyncToGenerator(regeneratorRuntime.mark(function _callee(fn, onCancel) {
        return regeneratorRuntime.wrap(function _callee$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    _ctx.prev = 0;
                    _ctx.next = 3;
                    return fn();
                case 3:
                    _ctx.next = 8;
                    break;
                case 5:
                    _ctx.prev = 5;
                    _ctx.t0 = _ctx["catch"](0);
                    if (_ctx.t0 === "exit") {
                        onCancel();
                    } else if (_ctx.t0.message) {
                        console.error(kleur.red(_ctx.t0.message));
                    }
                case 8:
                case "end":
                    return _ctx.stop();
            }
        }, _callee, null, [
            [
                0,
                5
            ]
        ]);
    }));
    return _swallowErrors.apply(this, arguments);
}
function getFunctionData(data, fn) {
    return _getFunctionData.apply(this, arguments);
}
function _getFunctionData() {
    _getFunctionData = _asyncToGenerator(regeneratorRuntime.mark(function _callee(data, fn) {
        var normalize, ref, loc, file;
        return regeneratorRuntime.wrap(function _callee$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    normalize = function(p) {
                        return p.replace(/(\/|\\)/, "-");
                    };
                    _ctx.prev = 1;
                    ;
                    _ctx.next = 5;
                    return getFnLoc(fn);
                case 5:
                    loc = _ctx.sent.source;
                    file = loc.replace(config.getOutputDir(), "").replace(/\.js$/, "").replace("file:///", "");
                    return _ctx.abrupt("return", (ref = data.filter(function(item) {
                        return item.name === fn.name && normalize(item.file) === normalize(file);
                    })) === null || ref === void 0 ? void 0 : ref[0]);
                case 10:
                    _ctx.prev = 10;
                    _ctx.t0 = _ctx["catch"](1);
                    return _ctx.abrupt("return", undefined);
                case 13:
                case "end":
                    return _ctx.stop();
            }
        }, _callee, null, [
            [
                1,
                10
            ]
        ]);
    }));
    return _getFunctionData.apply(this, arguments);
}
export function run(dir, functions) {
    return _run.apply(this, arguments);
}
function _run() {
    _run = _asyncToGenerator(regeneratorRuntime.mark(function _callee1(dir, functions) {
        var ref, pkgJson, data, flags, args, crnt, ref4, functionName, helpText, command;
        return regeneratorRuntime.wrap(function _callee$(_ctx1) {
            while(1)switch(_ctx1.prev = _ctx1.next){
                case 0:
                    ;
                    setRoot(dir);
                    autocomplete.listen(functions);
                    _dir = dir;
                    _functions = functions;
                    _ctx1.next = 7;
                    return config.getPkgJson();
                case 7:
                    pkgJson = _ctx1.sent;
                    _ctx1.next = 10;
                    return config.getDataFile();
                case 10:
                    data = _ctx1.sent;
                    flags = [];
                    args = process.argv.slice(2);
                case 13:
                    if (!(args.length > 0)) {
                        _ctx1.next = 22;
                        break;
                    }
                    crnt = args[0];
                    if (!(crnt && crnt[0] === "-")) {
                        _ctx1.next = 19;
                        break;
                    }
                    {
                        flags.push(args.shift());
                    }
                    _ctx1.next = 20;
                    break;
                case 19:
                    return _ctx1.abrupt("break", 22);
                case 20:
                    _ctx1.next = 13;
                    break;
                case 22:
                    ;
                    functionName = (ref4 = args.shift()) !== null && ref4 !== void 0 ? ref4 : "";
                    if (functionName[0] === "_") {
                        // disallow calling of hidden functions
                        functionName = "";
                    }
                    if (!(functionName === "autocomplete")) {
                        _ctx1.next = 35;
                        break;
                    }
                    if (!(args[0] === "disable")) {
                        _ctx1.next = 32;
                        break;
                    }
                    _ctx1.next = 29;
                    return autocomplete.uninstall();
                case 29:
                    return _ctx1.abrupt("return");
                case 32:
                    _ctx1.next = 34;
                    return autocomplete.setup();
                case 34:
                    return _ctx1.abrupt("return");
                case 35:
                    if (!(functionName === "help")) {
                        _ctx1.next = 39;
                        break;
                    }
                    _ctx1.next = 38;
                    return runInternal(dir, functions, "");
                case 38:
                    return _ctx1.abrupt("return");
                case 39:
                    _ctx1.next = 41;
                    return (ref = functions.__onStart__) === null || ref === void 0 ? void 0 : ref.call(functions);
                case 41:
                    if (functionName) {
                        _ctx1.next = 52;
                        break;
                    }
                    console.log(kleur.gray("Check usage by running \"".concat(pkgJson.name, " help\"")));
                case 43:
                    if (!true) {
                        _ctx1.next = 52;
                        break;
                    }
                    ;
                    _ctx1.next = 47;
                    return prompts({
                        type: "autocomplete",
                        name: "command",
                        message: "",
                        choices: _toConsumableArray(Object.keys(functions).filter(function(name) {
                            return name[0] !== "_";
                        }).map(function(key) {
                            return {
                                title: camelCaseToHyphen(key),
                                value: key
                            };
                        })),
                        onState: function() {
                            var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(param) {
                                var value, d;
                                return regeneratorRuntime.wrap(function _callee$(_ctx) {
                                    while(1)switch(_ctx.prev = _ctx.next){
                                        case 0:
                                            value = param.value;
                                            _ctx.next = 3;
                                            return getFunctionData(data, functions[value]);
                                        case 3:
                                            d = _ctx.sent;
                                            helpText = d ? d.description : "";
                                        case 5:
                                        case "end":
                                            return _ctx.stop();
                                    }
                                }, _callee);
                            }));
                            return function(_) {
                                return _ref.apply(this, arguments);
                            };
                        }(),
                        // @ts-ignore
                        onRender: function onRender() {
                            // @ts-ignore
                            this.msg = [
                                "Select a command",
                                helpText ? kleur.gray("(".concat(helpText, ")")) : null, 
                            ].filter(Boolean).join(" ");
                        }
                    }, {
                        onCancel: exit
                    });
                case 47:
                    command = _ctx1.sent.command;
                    _ctx1.next = 50;
                    return swallowErrors(_asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                        return regeneratorRuntime.wrap(function _callee$(_ctx) {
                            while(1)switch(_ctx.prev = _ctx.next){
                                case 0:
                                    _ctx.next = 2;
                                    return runInternal(dir, functions, command);
                                case 2:
                                case "end":
                                    return _ctx.stop();
                            }
                        }, _callee);
                    })), function() {
                        console.log("Press CTRL-C again to exit");
                    });
                case 50:
                    _ctx1.next = 43;
                    break;
                case 52:
                    _ctx1.next = 54;
                    return swallowErrors(_asyncToGenerator(regeneratorRuntime.mark(function _callee() {
                        return regeneratorRuntime.wrap(function _callee$(_ctx) {
                            while(1)switch(_ctx.prev = _ctx.next){
                                case 0:
                                    _ctx.next = 2;
                                    return runInternal(dir, functions, functionName);
                                case 2:
                                case "end":
                                    return _ctx.stop();
                            }
                        }, _callee);
                    })), exit);
                case 54:
                    exit();
                case 55:
                case "end":
                    return _ctx1.stop();
            }
        }, _callee1);
    }));
    return _run.apply(this, arguments);
}
export function runInternal(dir, fns, functionName) {
    return _runInternal.apply(this, arguments);
}
function _runInternal() {
    _runInternal = _asyncToGenerator(regeneratorRuntime.mark(function _callee(dir, fns, functionName) {
        var paramQueue, version, name2, pkgJason, _version, data, command, fn, ref, ref5, commands, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, name1, value, functionData, ref6, ref7, ref8, ref9, fnConfig, cancledRef, onCancel, params, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, param1, output, _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    onCancel = function _onCancel() {
                        cancledRef.current = true;
                        // thowing will cancel the current interaction
                        throw "exit";
                    };
                    paramQueue = _args.length > 3 && _args[3] !== void 0 ? _args[3] : process.argv.slice(3);
                    version = "unknown";
                    name2 = "untitled";
                    _ctx.next = 6;
                    return config.getPkgJson();
                case 6:
                    pkgJason = _ctx.sent;
                    ;
                    version = (_version = pkgJason.version) !== null && _version !== void 0 ? _version : version;
                    name2 = pkgJason.name ? pkgJason.name.replace(/@[^\/]+\//, "") : name2;
                    _ctx.next = 12;
                    return require(path.join(dir, "./cli.json"));
                case 12:
                    data = _ctx.sent;
                    command = hyphenToCamelCase(functionName);
                    fn = fns[command];
                    if (!(!command || !fn)) {
                        _ctx.next = 48;
                        break;
                    }
                    ;
                    commands = [];
                    _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    _ctx.prev = 19;
                    _iterator = Object.entries(fns).filter(function(param) {
                        var _param = _slicedToArray(param, 1), name = _param[0];
                        return name[0] !== "_";
                    })[Symbol.iterator]();
                case 21:
                    if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                        _ctx.next = 30;
                        break;
                    }
                    _value = _slicedToArray(_step.value, 2), name1 = _value[0], value = _value[1];
                    _ctx.next = 25;
                    return getFunctionData(data, value);
                case 25:
                    functionData = _ctx.sent;
                    if (functionData) {
                        ;
                        commands.push({
                            name: camelCaseToHyphen(name1),
                            description: (ref6 = functionData === null || functionData === void 0 ? void 0 : functionData.description) !== null && ref6 !== void 0 ? ref6 : ""
                        });
                    } else {
                        console.error("failed to identify paramaters for function ".concat(name1));
                    }
                case 27:
                    _iteratorNormalCompletion = true;
                    _ctx.next = 21;
                    break;
                case 30:
                    _ctx.next = 36;
                    break;
                case 32:
                    _ctx.prev = 32;
                    _ctx.t0 = _ctx["catch"](19);
                    _didIteratorError = true;
                    _iteratorError = _ctx.t0;
                case 36:
                    _ctx.prev = 36;
                    _ctx.prev = 37;
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                case 39:
                    _ctx.prev = 39;
                    if (!_didIteratorError) {
                        _ctx.next = 42;
                        break;
                    }
                    throw _iteratorError;
                case 42:
                    return _ctx.finish(39);
                case 43:
                    return _ctx.finish(36);
                case 44:
                    ;
                    help({
                        name: (ref7 = (ref = fns.__name__) === null || ref === void 0 ? void 0 : ref.call(fns)) !== null && ref7 !== void 0 ? ref7 : name2,
                        version: (ref8 = (ref5 = fns.__version__) === null || ref5 === void 0 ? void 0 : ref5.call(fns)) !== null && ref8 !== void 0 ? ref8 : version,
                        commands: commands
                    });
                    _ctx.next = 94;
                    break;
                case 48:
                    ;
                    _ctx.next = 51;
                    return (ref9 = fns.__beforeFn__) === null || ref9 === void 0 ? void 0 : ref9.call(fns, fn);
                case 51:
                    _ctx.next = 53;
                    return getFunctionData(data, fn);
                case 53:
                    fnConfig = _ctx.sent;
                    if (fnConfig) {
                        _ctx.next = 56;
                        break;
                    }
                    throw Error("filed to idenfity params for ".concat(fn.name));
                case 56:
                    cancledRef = {
                        current: false
                    };
                    ;
                    params = [];
                    _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                    _ctx.prev = 60;
                    _iterator2 = fnConfig.params[Symbol.iterator]();
                case 62:
                    if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                        _ctx.next = 74;
                        break;
                    }
                    param1 = _step2.value;
                    if (!cancledRef.current) {
                        _ctx.next = 66;
                        break;
                    }
                    return _ctx.abrupt("return");
                case 66:
                    _ctx.t1 = params;
                    _ctx.next = 69;
                    return getValue(param1, paramQueue, onCancel, cancledRef);
                case 69:
                    _ctx.t2 = _ctx.sent;
                    _ctx.t1.push.call(_ctx.t1, _ctx.t2);
                case 71:
                    _iteratorNormalCompletion2 = true;
                    _ctx.next = 62;
                    break;
                case 74:
                    _ctx.next = 80;
                    break;
                case 76:
                    _ctx.prev = 76;
                    _ctx.t3 = _ctx["catch"](60);
                    _didIteratorError2 = true;
                    _iteratorError2 = _ctx.t3;
                case 80:
                    _ctx.prev = 80;
                    _ctx.prev = 81;
                    if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                        _iterator2.return();
                    }
                case 83:
                    _ctx.prev = 83;
                    if (!_didIteratorError2) {
                        _ctx.next = 86;
                        break;
                    }
                    throw _iteratorError2;
                case 86:
                    return _ctx.finish(83);
                case 87:
                    return _ctx.finish(80);
                case 88:
                    if (!cancledRef.current) {
                        _ctx.next = 90;
                        break;
                    }
                    return _ctx.abrupt("return");
                case 90:
                    _ctx.next = 92;
                    return fn.apply(void 0, _toConsumableArray(params));
                case 92:
                    output = _ctx.sent;
                    return _ctx.abrupt("return", output);
                case 94:
                case "end":
                    return _ctx.stop();
            }
        }, _callee, null, [
            [
                19,
                32,
                36,
                44
            ],
            [
                37,
                ,
                39,
                43
            ],
            [
                60,
                76,
                80,
                88
            ],
            [
                81,
                ,
                83,
                87
            ]
        ]);
    }));
    return _runInternal.apply(this, arguments);
}
export function call(fn) {
    return _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
        var _len, params, _key, name, _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    for(_len = _args.length, params = new Array(_len), _key = 0; _key < _len; _key++){
                        params[_key] = _args[_key];
                    }
                    name = fn.name;
                    if (!(_dir && name)) {
                        _ctx.next = 6;
                        break;
                    }
                    _ctx.next = 5;
                    return runInternal(_dir, _objectSpread({}, _functions, _defineProperty({}, name, fn)), name, params);
                case 5:
                    return _ctx.abrupt("return", _ctx.sent);
                case 6:
                    throw Error("Could not find function with name ".concat(fn));
                case 7:
                case "end":
                    return _ctx.stop();
            }
        }, _callee);
    }));
}
function exit() {
    process.exit();
}
