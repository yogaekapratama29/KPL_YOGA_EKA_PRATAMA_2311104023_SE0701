import regeneratorRuntime from "regenerator-runtime";
import { exec } from "child_process";
import dedent from "dedent";
import { createSpinner } from "nanospinner";
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
// NOT CRYPTOGRAPHIC
var SEED = 5381;
// When we have separate strings it's useful to run a progressive
// version of djb2 where we pretend that we're still looping over
// the same string
var phash = function(h, x) {
    var i = x.length;
    while(i){
        h = h * 33 ^ x.charCodeAt(--i);
    }
    return h;
};
// This is a djb2 hashing function
export var hash = function(x) {
    var str = "";
    if (typeof x === "string") {
        str = x;
    } else {
        str = JSON.stringify(x);
    }
    return phash(SEED, str) + "";
};
function padRight(str, length) {
    var padding = Math.max(length - str.length, 0);
    return "".concat(str).concat(" ".repeat(padding));
}
export function formatTable(data) {
    var indent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var colWidths = [];
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var row = _step.value;
            for(var i = 0; i < row.length; i++){
                var _i;
                colWidths[i] = Math.max((_i = colWidths[i]) !== null && _i !== void 0 ? _i : 0, row[i].length);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    var table = "";
    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
    try {
        for(var _iterator1 = data[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
            var row1 = _step1.value;
            for(var i1 = 0; i1 < row1.length; i1++){
                var col = row1[i1];
                if (i1 > 0) {
                    table += "\t";
                }
                table += padRight(col, colWidths[i1]);
            }
            table += "\n";
        }
    } catch (err) {
        _didIteratorError1 = true;
        _iteratorError1 = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                _iterator1.return();
            }
        } finally{
            if (_didIteratorError1) {
                throw _iteratorError1;
            }
        }
    }
    return dedent(table).split("\n").join("\n".concat(" ".repeat(indent)));
}
export function printTable(data) {
    console.log(formatTable(data));
}
export var camelCaseToHyphen = function(name) {
    return name.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
};
export var hyphenToCamelCase = function(name) {
    return name.replace(/-./g, function(m) {
        return m[1].toUpperCase();
    });
};
export function spinner(config, fn) {
    return _spinner.apply(this, arguments);
}
function _spinner() {
    _spinner = _asyncToGenerator(regeneratorRuntime.mark(function _callee(config, fn) {
        var spinner1, out;
        return regeneratorRuntime.wrap(function _callee$(_ctx) {
            while(1)switch(_ctx.prev = _ctx.next){
                case 0:
                    spinner1 = createSpinner(config.name);
                    _ctx.next = 3;
                    return fn();
                case 3:
                    out = _ctx.sent;
                    spinner1.success();
                    return _ctx.abrupt("return", out);
                case 6:
                case "end":
                    return _ctx.stop();
            }
        }, _callee);
    }));
    return _spinner.apply(this, arguments);
}
export var promiseExec = function(command, cwd) {
    return new Promise(function(resolve, reject) {
        exec(command, {
            cwd: cwd
        }, function(error, stdout) {
            if (error) {
                console.log(error);
                reject();
            } else {
                resolve(dedent(stdout));
            }
        });
    });
};
